import { File as File$1 } from 'buffer';

/**
 * CircuitStatus choices
 */
type CircuitStatus = "Queued" | "In Progress" | "Ready" | "Failed";

/**
 * CircuitType choices
 */
type CircuitType = "circom" | "gnark" | "halo2" | "noir";

/**
 * Response for getting Circom circuit info.
 */
type CircomCircuitInfoResponse = {
    circuit_id: string;
    circuit_name: string;
    circuit_type: CircuitType;
    date_created: string;
    num_proofs: number;
    proving_scheme: string;
    status: CircuitStatus;
    team: string;
    /**
     * Total compute time in ISO8601 format. This does not include the Queued time.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds. This does not include the Queued time.
     */
    compute_time_sec?: number;
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    uploaded_file_name: string;
    verification_key?: Record<string, any>;
    error?: string;
    curve: string;
    num_constraints?: number;
    num_outputs?: number;
    num_private_inputs?: number;
    num_public_inputs?: number;
};

/**
 * Response for getting Gnark circuit info.
 */
type GnarkCircuitInfoResponse = {
    circuit_id: string;
    circuit_name: string;
    circuit_type: CircuitType;
    date_created: string;
    num_proofs: number;
    proving_scheme: string;
    status: CircuitStatus;
    team: string;
    /**
     * Total compute time in ISO8601 format. This does not include the Queued time.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds. This does not include the Queued time.
     */
    compute_time_sec?: number;
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    uploaded_file_name: string;
    verification_key?: Record<string, any>;
    error?: string;
    curve: string;
    gnark_version: string;
};

/**
 * Response for getting Halo2 circuit info.
 */
type Halo2CircuitInfoResponse = {
    circuit_id: string;
    circuit_name: string;
    circuit_type: CircuitType;
    date_created: string;
    num_proofs: number;
    proving_scheme: string;
    status: CircuitStatus;
    team: string;
    /**
     * Total compute time in ISO8601 format. This does not include the Queued time.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds. This does not include the Queued time.
     */
    compute_time_sec?: number;
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    uploaded_file_name: string;
    verification_key?: Record<string, any>;
    error?: string;
    class_name: string;
    curve: string;
    degree: number;
    halo2_version: string;
};

/**
 * Response for getting Noir circuit info.
 */
type NoirCircuitInfoResponse = {
    circuit_id: string;
    circuit_name: string;
    circuit_type: CircuitType;
    date_created: string;
    num_proofs: number;
    proving_scheme: string;
    status: CircuitStatus;
    team: string;
    /**
     * Total compute time in ISO8601 format. This does not include the Queued time.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds. This does not include the Queued time.
     */
    compute_time_sec?: number;
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    uploaded_file_name: string;
    verification_key?: Record<string, any>;
    error?: string;
    acir_opcodes?: number;
    circuit_size?: number;
    nargo_package_name: string;
};

/**
 * ProofStatus choices
 */
type ProofStatus = "Queued" | "In Progress" | "Ready" | "Failed";

/**
 * Response for getting proof info.
 */
type ProofInfoResponse = {
    proof_id: string;
    circuit_name: string;
    circuit_id: string;
    circuit_type: CircuitType;
    date_created: string;
    perform_verify: boolean;
    status: ProofStatus;
    team: string;
    /**
     * Total compute time in ISO8601 format. This does not include the Queued time.
     */
    compute_time?: number;
    /**
     * Total compute time in seconds. This does not include the Queued time.
     */
    compute_time_sec?: number;
    compute_times?: any;
    /**
     * Total size of stored file(s) in bytes.
     */
    file_size?: number;
    proof_input?: Record<string, any>;
    proof?: Record<string, any>;
    public?: any;
    verification_key?: Record<string, any>;
    error?: string;
};

/**
 * The minimum log level to print.
 */
type LogLevel = "silent" | "fatal" | "error" | "warn" | "info" | "debug" | "trace";

type BrowserFile = File;
declare const File: typeof File$1 | {
    new (fileBits: BlobPart[], fileName: string, options?: FilePropertyBag | undefined): File;
    prototype: File;
};

type CircuitInfoResponse = CircomCircuitInfoResponse | Halo2CircuitInfoResponse | GnarkCircuitInfoResponse | NoirCircuitInfoResponse;
/**
 * The options for authenticating with the API.
 */
interface AuthOptions {
    /**
     * The API key to use for authentication.
     */
    apiKey?: string;
    /**
     * The base URL for the API.
     */
    baseUrl?: string;
}
/**
 * Represents the primary client for interacting with the Sindri ZKP service API. This class serves
 * as the central entry point for the SDK, facilitating various operations such as compiling ZKP
 * circuits and generating proofs.
 *
 * The {@link SindriClient} class encapsulates all the necessary methods and properties required to
 * communicate effectively with the Sindri ZKP service, handling tasks like authentication, request
 * management, and response processing.
 *
 * Usage of this class typically involves instantiating it with appropriate authentication options
 * and then utilizing its methods to interact with the service.
 *
 * @example
 * // Create an instance of the `SindriClient` class.
 * const client = new SindriClient({ apiKey: 'your-api-key' });
 *
 * // Use the client to interact with the Sindri ZKP service...
 */
declare class SindriClient {
    /**
     * Represents the polling interval in milliseconds used for querying the status of an endpoint.
     * This value determines the frequency at which the SDK polls an endpoint to check for any changes
     * in status.
     *
     * The choice of polling interval is critical for balancing responsiveness against resource
     * consumption.  A shorter interval leads to more frequent updates, beneficial for
     * rapidly-changing statuses, but at the expense of higher network and computational load. In
     * contrast, a longer interval reduces resource usage but may delay the detection of status
     * changes.
     *
     * For more complex ZKP circuits, which may take longer to compile, considering a larger polling
     * interval could be advantageous. This approach minimizes unnecessary network traffic and
     * computational effort while awaiting the completion of these time-intensive operations.
     *
     * The default value is set to 1000 milliseconds (1 second), offering a general balance. However,
     * it can and should be adjusted based on the expected complexity and compilation time of the
     * circuits being processed.
     */
    pollingInterval: number;
    /**
     * Constructs a new instance of the {@link SindriClient} class for interacting with the Sindri ZKP
     * service.  This constructor initializes the client with the necessary authentication options.
     *
     * The provided `authOptions` parameter allows for specifying authentication credentials and
     * configurations required for the client to communicate securely with the service.  See
     * {@link SindriClient.authorize} for more details about how authentication credentials are sourced.
     *
     * @param authOptions - The authentication options for the client, including
     * credentials like API keys or tokens. Defaults to an empty object if not provided.
     *
     * @example
     * // Instantiating the SindriClient with authentication options
     * const client = new SindriClient({ apiKey: 'sindri-...-fskd' });
     *
     * @see {@link SindriClient.authorize} for information on retrieving this value.
     */
    constructor(authOptions?: AuthOptions);
    /**
     * Retrieves the current value of the client's API key used for authenticating with the Sindri ZKP
     * service.  This property is crucial for ensuring secure communication with the API and is
     * typically set during client initialization.
     *
     * If the API key is not set or is in an invalid format (not a string), this getter returns
     * `null`.  Proper management of the API key is essential for the security and proper functioning
     * of the SDK.
     *
     * @returns The current API key if set and valid, otherwise `null`.
     *
     * @example
     * const currentApiKey = client.apiKey;
     * if (currentApiKey) {
     *   console.log('API Key is set.');
     * } else {
     *   console.log('API Key is not set or is invalid.');
     * }
     */
    get apiKey(): string | null;
    /**
     * Retrieves the current base URL of the Sindri ZKP service that the client is configured to
     * interact with.  This URL forms the foundation of all API requests made by the client and is
     * typically set during client initialization. Anyone other than employees at Sindri can typically
     * ignore this and use the default value of `https://sindri.app`.
     *
     * @returns The current base URL of the Sindri ZKP service.
     *
     * @example
     * console.log(`Current base URL: ${client.baseUrl}`);
     */
    get baseUrl(): string;
    /** Retrieves the current log level of the client. The log level determines the verbosity of logs
     * produced by the client which can be crucial for debugging and monitoring the client's
     * interactions with the Sindri ZKP service.
     *
     * @returns The current log level of the client.
     *
     * @example
     * console.log(`Current log level: ${client.logLevel}`);
     */
    get logLevel(): LogLevel;
    /**
     * Sets the client's log level. This level determines the verbosity of logs produced by the
     * client, allowing for flexible control over the amount of information logged during operation.
     *
     * @param level - The new log level to set for the client.
     *
     * @example
     * // Set log level to debug.
     * client.logLevel = "debug";
     */
    set logLevel(level: LogLevel);
    /**
     * Authorizes the client with the Sindri ZKP service using the provided authentication options.
     * This method is called automatically after initializing a client, but you may call it again if
     * you would like to change the credentials. The logic around how credentials is as follows:
     *
     * 1. Any explicitly specified options in `authOptions` are always used if provided.
     * 2. The `SINDRI_API_KEY` and `SINDRI_BASE_URL` environment variables are checked next.
     * 3. The settings in `sindri.conf.json` (produced by running `sindri login` on the command-line) will be checked after that.
     * 4. Finally, the default value of `https://sindri.app` will be used for the base URL (this is
     * typically what you want unless you're an employee at Sindri). The API key will remain unset and
     * you will only be able to make requests that allow anonymous access.
     *
     *
     * @param authOptions - The authentication details required to authorize the client.
     * @returns True if authorization is successful, false otherwise.
     *
     * @example
     * const authOptions = { apiKey: 'sindri-...-jskd' };
     * const isAuthorized = client.authorize(authOptions);
     * if (isAuthorized) {
     *   console.log('Client is fully authorized.');
     * } else {
     *   console.log('Client is not authorized.');
     * }
     */
    authorize(authOptions: AuthOptions): boolean;
    /**
     * Asynchronously creates and deploys a new circuit, initiating its compilation process.  This
     * method is essential for submitting new versions of circuits to the Sindri ZKP service for
     * compilation. Upon deployment, it continuously polls the service to track the compilation status
     * until the process either completes successfully or fails.
     *
     * The method accepts two parameters: `project` and `tags`. The `project` parameter can be either
     * a string representing the path to the project or an array of files (browser or Node.js file
     * objects) constituting the circuit. The `tags` parameter is used to assign tags to the deployed
     * circuit, facilitating versioning and identification. By default, the circuit is tagged as
     * "latest".
     *
     * After successful deployment and compilation, the method returns a `CircuitInfoResponse` object,
     * which includes details about the compiled circuit, such as its identifier and status.
     *
     * @param project - In Node.js, this can either be a path to the root
     * directory of a Sindri project, the path to a gzipped tarball containing the project, or an
     * array of `buffer.File` objects. In a web browser, it can only be an array of `File` objects.
     * @param tags - The list of tags, or singular tag if a string is passed, that
     * should be associated with the deployed circuit. Defaults to `["latest"]`. Specify an empty
     * array to indicate that you don't care about the compilation outputs and just want to see if it
     * the circuit will compile.
     * @returns A promise which resolves to the details of the deployed circuit.
     *
     * @example
     * // Deploy a circuit with a project identifier and default `latest` tag.
     * const circuit = await client.createCircuit("/path/to/circuit-directory/");
     * console.log("Did circuit compilation succeed?", circuit.status);
     *
     * @example
     * // Deploy a circuit with files and custom tags.
     * await client.createCircuit([file1, file2], ['v1.0', 'experimental']);
     */
    createCircuit(project: string | Array<BrowserFile | File$1>, tags?: string | string[] | null): Promise<CircuitInfoResponse>;
    /**
     * Retrieves all proofs associated with a specified circuit.  This method is essential for
     * obtaining a comprehensive list of proofs generated for a given circuit, identified by its
     * unique circuit ID. It returns an array of `ProofInfoResponse` objects, each representing a
     * proof associated with the circuit.
     *
     * The method is particularly useful in scenarios where tracking or auditing all proofs of a
     * circuit is necessary. This could include verifying the integrity of proofs, understanding their
     * usage, or simply enumerating them for record-keeping.
     *
     * The `circuitId` parameter is a string that uniquely identifies the circuit in question. It's
     * crucial to provide the correct circuit ID to retrieve the corresponding proofs accurately.
     *
     * @param circuitId - The unique identifier of the circuit for which proofs are to be retrieved.
     * @returns A promise that resolves to an array of details for each associated proof.
     *
     * @example
     * const proofs = await client.getAllCircuitProofs(circuitId);
     * console.log("Proofs:', proofs);
     */
    getAllCircuitProofs(circuitId: string): Promise<ProofInfoResponse[]>;
    /**
     * Retrieves all circuits associated with the team.  This method fetches a list of all circuits
     * that have been created or accessed by the currently authenticated team. It's a key method for
     * managing and monitoring circuit usage within a team, offering insights into the variety and
     * scope of circuits in use.
     *
     * @returns A promise that resolves to an array of circuit information responses.
     *
     * @example
     * const circuits = await = client.getAllCircuits();
     * console.log("Circuits:", circuits);
     */
    getAllCircuits(): Promise<CircuitInfoResponse[]>;
    /**
     * Retrieves all proofs associated with the team.  This method is designed to fetch a list of all
     * proofs generated by the current team across all circuits, providing a holistic view of the
     * team's activities in proof generation and management.
     *
     * Utilizing this method helps in gaining insights into the proofs created, their status, and
     * other relevant details, which is essential for effective team-wide proof tracking and auditing.
     * It returns a promise that resolves to an array of {@link ProofInfoResponse} objects, where each
     * object encapsulates detailed information about a specific proof.
     *
     * @returns A promise that resolves to an array of proofs.
     *
     * @example
     * const proofs = await clientgetAllProofs()
     * console.log("How many proofs?", proofs.length);
     */
    getAllProofs(): Promise<ProofInfoResponse[]>;
    /**
     * Retrieves a specific circuit using its unique circuit ID.  This method is crucial for obtaining
     * detailed information about a particular circuit,  identified by the provided `circuitId`. It's
     * especially useful when detailed insights  or operations on a single circuit are required, rather
     * than handling multiple circuits.
     *
     * *Note:* In case the provided `circuitId` is invalid or does not correspond to an existing circuit,
     * the promise may reject, indicating an error. Proper error handling is therefore essential when using this method.
     *
     * @param circuitId - The unique identifier of the circuit to retrieve.
     * @returns A promise that resolves to the information about the specified circuit.
     *
     * @example
     * const circuit = await client.getCircuit(circuitId);
     * console.log('Circuit details:', circuit);
     */
    getCircuit(circuitId: string): Promise<CircuitInfoResponse>;
    /**
     * Retrieves detailed information about a specific proof, identified by its unique proof ID.  This
     * method is vital for obtaining individual proof details, facilitating in-depth analysis or
     * verification of a particular proof within the system.
     *
     * The `proofId` parameter is the key identifier for the proof, and it should be provided to fetch
     * the corresponding information. The method returns a promise that resolves to a
     * {@link ProofInfoResponse}, containing all relevant details of the proof.
     *
     * @param proofId - The unique identifier of the proof to retrieve.
     * @returns A promise that resolves to the data about the specified proof.
     *
     * @example
     * const proof = await client.getProof(proofId);
     * console.log("Proof details:", proof);
     */
    getProof(proofId: string): Promise<ProofInfoResponse>;
    /**
     * Generates a proof for a specified circuit.  This method is critical for creating a new proof
     * based on a given circuit, identified by `circuitId`, and the provided `proofInput`. It's
     * primarily used to validate or verify certain conditions or properties of the circuit without
     * revealing underlying data or specifics. The method continuously polls the service to track the
     * compilation status until the process either completes successfully or fails.
     *
     * The `circuitId` parameter specifies the unique identifier of the circuit for which the proof is
     * to be generated.  The `proofInput` is a string that represents the necessary input data or
     * parameters required for generating the proof.
     *
     * @param circuitId - The unique identifier of the circuit for which the proof is being generated.
     * @param proofInput - The input data required for generating the proof. This should be a string
     * containing either JSON data or TOML data (in the case of Noir).
     * @returns A promise that resolves to the information of the generated proof.
     *
     * @example
     * const proof = await client.proveCircuit(circuitId, '{"X": 23, "Y": 52}');
     * console.log("Generated proof:", proof);
     */
    proveCircuit(circuitId: string, proofInput: string): Promise<ProofInfoResponse>;
}

declare const _default: SindriClient;

export { type AuthOptions, type CircomCircuitInfoResponse, type CircuitInfoResponse, type CircuitStatus, type CircuitType, type GnarkCircuitInfoResponse, type Halo2CircuitInfoResponse, type LogLevel, type NoirCircuitInfoResponse, type ProofInfoResponse, type ProofStatus, SindriClient, _default as default };
